/// A trait representing the ability to transmit IR pulses.
///
/// An implementor of this trait is responsible for taking a slice of pulse widths (in microseconds)
/// that encode an entire IR message (on-time/off-time pairs). Each entry in the slice corresponds to
/// either a "burst" (LED on, typically modulated at ~38kHz) or a "gap" (LED fully off).
///
/// Generally, the first element in `pulses` is the duration of the IR "on" time, the second element
/// is the "off" time, the third is "on" again, and so on, alternating until the full message is sent.
/// Thus, for a slice like `[157, 263, 157, 552]`, the transmitter should:
///
/// ```text
/// 1. Turn the IR LED on (modulated at the carrier frequency) for 157 μs,
/// 2. Turn it off for 263 μs,
/// 3. Turn it on again for 157 μs,
/// 4. Turn it off again for 552 μs,
/// etc.
/// ```
///
/// In practice, these pulses are generated by an IR protocol encoder,
/// but how you **apply** them (using hardware registers, a kernel interface like `/dev/lirc0`, or a
/// software-based emulator) depends on the specific implementation.
///
/// # Examples
///
/// ```
/// use brickbeam::{PulseTransmitter, Result};
///
/// struct MyTransmitter;
///
/// impl PulseTransmitter for MyTransmitter {
///     fn send_pulses(&self, pulses: &[u32]) -> Result<()> {
///         // Insert your hardware or emulation logic here.
///         // For instance, toggling a GPIO pin on/off to match the durations.
///         println!("Sending IR pulses: {:?}", pulses);
///         Ok(())
///     }
/// }
/// ```
///
/// # Errors
///
/// The `Result` can indicate a failure to access the IR hardware or an internal error if pulses
/// cannot be sent successfully. Implementors should return an appropriate `Error` variant if
/// transmission fails.
pub trait PulseTransmitter {
    /// Sends the given IR pulse sequence.
    ///
    /// The `pulses` slice contains alternating on/off durations (in microseconds).
    /// The first value is the length of time to transmit (LED on), the second is a gap (LED off),
    /// and so on, until the entire IR message is complete.
    fn send_pulses(&self, pulses: &[u32]) -> crate::Result<()>;
}
